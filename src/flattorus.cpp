/*
 *  flat_torus: Isometric embedding of a flat torus
 *  Copyright (C) 2012 Vincent Borrelli, Saïd Jabrane, Francis Lazarus and Boris Thibert
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 *  If you modify this software, you should include a notice giving the
 *  name of the person performing the modification, the date of modification,
 *  and the reason for such modification.
 *
 *  Contact: francis.lazarus@gipsa-lab.fr, boris.thibert@imag.fr
 *
 *  Note that the GNU General Public License does not permit incorporating
 *  the Software into proprietary programs.
 */ 

//************************************************************************
//                                                    flat_torus.cpp
//                                                  -------------------
//    written by:        : Vincent Borrelli, Saïd Jabrane, Francis Lazarus and Boris Thibert
//    email                : francis.lazarus@gipsa-lab.fr, boris.thibert@imag.fr
//************************************************************************

typedef double NB_TYPE;  // NE PAS DEPLACER

#include <iostream> 
#include <cstdlib> 
//#include <omp.h>         // For openMP if needed
#include "TOR_torus.h"
#include "CYL_cylinder.h"
#include "ISO_embedding.h"
#include "ISO_parser.h"
#include <ctime>

BZ_DECLARE_FUNCTION2_RET(dot_prod , NB_TYPE)
BZ_DECLARE_FUNCTION2_RET(substract , UTI_3vector<NB_TYPE>)
BZ_DECLARE_FUNCTION_RET(norm2_2form, NB_TYPE)
BZ_DECLARE_FUNCTION(J0_inv)
BZ_DECLARE_FUNCTION2(cross_prod)

int main(int argc, char* argv[]) 
{
  bool is_standard_bis;
  bool is_no_output;
  int output_level(1);
  int debug_level(0);
  TOR_embed_type embedding_type = TOR_STANDARD;
  int nx(10000), stage(0);
  int n_oscil[3]= {12,80,500};
  NB_TYPE r1=.2;
  NB_TYPE r2=.5;

  parse_command_line_iso(argc, argv, 
			 output_level, debug_level,
			 embedding_type, nx, n_oscil, r1, r2);

  cout << "Uses TOR_interp_order = " << TOR_interp_order 
       << " and TOR_deriv_order = " << TOR_deriv_order << endl;
  cout << "Uses CYL_interp_order = " << CYL_interp_order 
       << " and CYL_deriv_order = " << CYL_deriv_order << endl;
  cout << "Uses CYL_interp_order_S1 = " << CYL_interp_order_S1 
       << " and CYL_deriv_order_S1 = " << CYL_deriv_order_S1 << endl << endl;

  ISO_embedding<NB_TYPE> embedding(embedding_type, nx, r1, r2, 
 				     output_level, debug_level);

  int first_dir = 0; // Set first_dir to 1 or 2 to start with an other direction

  cout << "** Initial isometric default : I - f0^*<,> = Sum_i rho_i l_i*l_i" << endl;
  NB_TYPE rho_min = embedding.print_min_max_rho(-1); // coef_delta(-1) = 1
  assert( rho_min > 0 );
  cout << endl << "I - f0^*<,> belongs to the positive cone C generated by the li*li.";
  cout << endl;
  embedding.print_iso_default(-1, 0);
  cout << endl;
  
  cout << "** STAGE " << stage << " DIRECTION " << first_dir << " ** :" << endl;
  cout << "delta coeff = " << embedding.coef_delta( stage ) 
        << " N0 = " << n_oscil[0] << endl << endl;
  cout << "Since I - f0^*<,> belongs to the cone C, so does g0 - f0^*<,>." << endl;
  time_t tps0 = time (NULL); // clock_t tps0 = clock();
  cout << "Computation of the first corrugation..." << endl; 
  embedding.corrugation(stage, first_dir, n_oscil[0]);
  cout << "...done." << endl;
  NB_TYPE err = embedding.print_iso_default(stage, first_dir);
  embedding.reset_f0(); // We reset this embedding as the new f0!
  cout << "We reset f0 after the first corrugation." << endl;
  cout << "We check that g1 - f0^*<,> still belongs to C after f0 is reset:" << endl;
  stage = 1;
  rho_min = embedding.print_min_max_rho(stage);
  assert( rho_min > 0 );
  cout << endl;
  
  time_t tps1 = time (NULL); // clock_t tps1 = clock();
  cout << "Computing time for direction " << 0 << " : "
       << tps1-tps0 << " seconds" << std::endl << std::endl; 
  
  for (int i=1; i < 3; i++) { // i = 1 to 2
    int dir = (i+first_dir)%3; 
    cout << "** STAGE " << stage << " DIRECTION " << dir << " ** :" << endl;
    cout << "Coef delta = " << embedding.coef_delta( stage ) 
	 << " N" << i << " = " << n_oscil[i] << endl << endl;
    time_t tps0 = time (NULL); // clock_t tps0 = clock();
    
    cout << "Computation of the corrugation in direction " << dir << "..." << endl; 
   embedding.corrugation(stage, dir, n_oscil[i]);
   cout << "...done." << endl;
   cout << "We should have rho_"<< (dir +1)%3 << " positive:" << endl;
    embedding.print_min_max_rho(stage);
    cout << endl;
    NB_TYPE err = embedding.print_iso_default(stage, dir);
    
    time_t tps1 = time (NULL); // clock_t tps1 = clock();
      cout << "Computing time for direction " << dir << " : "
	   << tps1-tps0 << " seconds" << std::endl << std::endl; 
  }
}

